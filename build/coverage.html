
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>auth: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ziyan/gatewaysshd/auth/auth.go (0.0%)</option>
				
				<option value="file1">github.com/ziyan/gatewaysshd/cli/cli.go (0.0%)</option>
				
				<option value="file2">github.com/ziyan/gatewaysshd/cli/flags.go (0.0%)</option>
				
				<option value="file3">github.com/ziyan/gatewaysshd/cli/http.go (0.0%)</option>
				
				<option value="file4">github.com/ziyan/gatewaysshd/cli/run.go (0.0%)</option>
				
				<option value="file5">github.com/ziyan/gatewaysshd/db/db.go (0.0%)</option>
				
				<option value="file6">github.com/ziyan/gatewaysshd/db/migration.go (0.0%)</option>
				
				<option value="file7">github.com/ziyan/gatewaysshd/db/migrations/0000_initial.go (0.0%)</option>
				
				<option value="file8">github.com/ziyan/gatewaysshd/db/migrations/0001_add_administrator.go (0.0%)</option>
				
				<option value="file9">github.com/ziyan/gatewaysshd/db/migrations/0002_add_screenshot.go (0.0%)</option>
				
				<option value="file10">github.com/ziyan/gatewaysshd/db/migrations/0003_created_at.go (0.0%)</option>
				
				<option value="file11">github.com/ziyan/gatewaysshd/db/migrations/migrations.go (0.0%)</option>
				
				<option value="file12">github.com/ziyan/gatewaysshd/db/models.go (0.0%)</option>
				
				<option value="file13">github.com/ziyan/gatewaysshd/db/users.go (0.0%)</option>
				
				<option value="file14">github.com/ziyan/gatewaysshd/gateway/connection.go (0.0%)</option>
				
				<option value="file15">github.com/ziyan/gatewaysshd/gateway/gateway.go (0.0%)</option>
				
				<option value="file16">github.com/ziyan/gatewaysshd/gateway/service.go (0.0%)</option>
				
				<option value="file17">github.com/ziyan/gatewaysshd/gateway/session.go (0.0%)</option>
				
				<option value="file18">github.com/ziyan/gatewaysshd/gateway/tunnel.go (0.0%)</option>
				
				<option value="file19">github.com/ziyan/gatewaysshd/gateway/utils.go (0.0%)</option>
				
				<option value="file20">github.com/ziyan/gatewaysshd/main.go (0.0%)</option>
				
				<option value="file21">github.com/ziyan/gatewaysshd/util/debugutil/debugserver.go (0.0%)</option>
				
				<option value="file22">github.com/ziyan/gatewaysshd/util/debugutil/debugutil.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package auth

import (
        "bytes"
        "errors"
        "net"

        "github.com/op/go-logging"
        "github.com/oschwald/geoip2-golang"
        "golang.org/x/crypto/ssh"

        "github.com/ziyan/gatewaysshd/db"
)

var log = logging.MustGetLogger("auth")

var (
        ErrInvalidCredentials = errors.New("auth: invalid credentials")
)

func NewConfig(database db.Database, caPublicKeys []ssh.PublicKey, geoipDatabase string) (*ssh.ServerConfig, error) <span class="cov0" title="0">{
        authenticator := &amp;authenticator{
                database:      database,
                caPublicKeys:  caPublicKeys,
                geoipDatabase: geoipDatabase,
        }
        config := &amp;ssh.ServerConfig{
                PublicKeyCallback: authenticator.authenticate,
                AuthLogCallback:   authenticator.log,
        }
        return config, nil
}</span>

type authenticator struct {
        database      db.Database
        caPublicKeys  []ssh.PublicKey
        geoipDatabase string
}

func (self *authenticator) authenticate(meta ssh.ConnMetadata, publicKey ssh.PublicKey) (*ssh.Permissions, error) <span class="cov0" title="0">{
        // lookup location
        ip := meta.RemoteAddr().(*net.TCPAddr).IP
        location := self.lookupLocation(ip)

        // check certificate
        certificateChecker := &amp;ssh.CertChecker{
                IsUserAuthority: func(publicKey ssh.PublicKey) bool </span><span class="cov0" title="0">{
                        for _, caPublicKey := range self.caPublicKeys </span><span class="cov0" title="0">{
                                if bytes.Equal(caPublicKey.Marshal(), publicKey.Marshal()) </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                        <span class="cov0" title="0">log.Warningf("unknown authority: %v", publicKey)
                        return false</span>
                },
        }

        <span class="cov0" title="0">permissions, err := certificateChecker.Authenticate(meta, publicKey)
        log.Debugf("remote = %s, local = %s, public_key = %v, permissions = %v, err = %v", meta.RemoteAddr(), meta.LocalAddr(), publicKey, permissions, err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // update user in database
        <span class="cov0" title="0">user, err := self.database.PutUser(meta.User(), func(model *db.User) error </span><span class="cov0" title="0">{
                model.IP = ip.String()
                model.Location = location
                return nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // check for deactivated user
        <span class="cov0" title="0">if user.Disabled </span><span class="cov0" title="0">{
                return nil, ErrInvalidCredentials
        }</span>

        <span class="cov0" title="0">if user.Administrator </span><span class="cov0" title="0">{
                permissions.Extensions["administrator"] = ""
        }</span>

        // successful auth
        <span class="cov0" title="0">log.Infof("successful, username = %s, extensions = %q", meta.User(), permissions.Extensions)
        return permissions, nil</span>
}

func (self *authenticator) lookupLocation(ip net.IP) db.Location <span class="cov0" title="0">{
        var location db.Location
        d, err := geoip2.Open(self.geoipDatabase)
        if err != nil </span><span class="cov0" title="0">{
                return location
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := d.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Warningf("failed to close geoip database: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">r, err := d.City(ip)
        if err != nil </span><span class="cov0" title="0">{
                return location
        }</span>

        <span class="cov0" title="0">location.Country = r.Country.IsoCode
        location.Latitude = r.Location.Latitude
        location.Longitude = r.Location.Longitude
        location.City = r.City.Names["en"]
        location.TimeZone = r.Location.TimeZone
        return location</span>
}

func (self *authenticator) log(meta ssh.ConnMetadata, method string, err error) <span class="cov0" title="0">{
        log.Debugf("remote = %s, local = %s, user = %s, method = %s, error = %v", meta.RemoteAddr(), meta.LocalAddr(), meta.User(), method, err)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package cli

import (
        "fmt"
        "os"

        "github.com/op/go-logging"
        "github.com/urfave/cli"
)

var log = logging.MustGetLogger("cli")

func Run(version, commit string, args []string) <span class="cov0" title="0">{
        app := cli.NewApp()
        app.EnableBashCompletion = true
        app.Name = "gatewaysshd"
        app.Version = fmt.Sprintf("%s.%s", version, commit)
        app.Usage = "A daemon that provides a meeting place for all your SSH tunnels."
        app.Flags = flags
        app.Before = func(c *cli.Context) error </span><span class="cov0" title="0">{
                formatter := logging.MustStringFormatter("%{color}%{time:2006-01-02T15:04:05.000-07:00} [%{level}] &lt;%{pid}&gt; [%{shortfile} %{shortfunc}] %{message}%{color:reset}")
                logging.SetBackend(logging.NewBackendFormatter(logging.NewLogBackend(os.Stderr, "", 0), formatter))
                if level, err := logging.LogLevel(c.String("log-level")); err == nil </span><span class="cov0" title="0">{
                        logging.SetLevel(level, "")
                }</span>
                <span class="cov0" title="0">log.Debugf("log level set to %s", logging.GetLevel(""))
                log.Noticef("started %s version %s", app.Name, app.Version)
                return nil</span>
        }
        <span class="cov0" title="0">app.After = func(c *cli.Context) error </span><span class="cov0" title="0">{
                log.Noticef("exiting %s version %s ...", app.Name, app.Version)
                return nil
        }</span>
        <span class="cov0" title="0">app.Action = run
        _ = app.Run(args)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cli

import (
        "os"
        "time"

        "github.com/urfave/cli"
        "golang.org/x/crypto/ssh"
)

var flags = []cli.Flag{
        cli.StringFlag{
                Name:  "log-level",
                Value: "DEBUG",
                Usage: "log level",
        },
        cli.StringFlag{
                Name:  "log-format",
                Value: "%{color}%{time:2006-01-02T15:04:05.000-07:00} [%{level:.4s}] [%{shortfile} %{shortfunc}] %{message}%{color:reset}",
                Usage: "log format",
        },
        cli.StringFlag{
                Name:  "listen-debug",
                Value: "127.0.0.1:6080",
                Usage: "debug listen endpoint",
        },
        cli.StringFlag{
                Name:  "listen-ssh",
                Value: ":2020",
                Usage: "ssh listen endpoint",
        },
        cli.StringFlag{
                Name:  "listen-http",
                Value: "127.0.0.1:2080",
                Usage: "http listen endpoint",
        },
        cli.StringFlag{
                Name:  "ca-public-key",
                Value: "id_rsa.ca.pub",
                Usage: "path to certificate authority public key",
        },
        cli.StringFlag{
                Name:  "host-public-key",
                Value: "id_rsa.pub",
                Usage: "path to host public key or certificate",
        },
        cli.StringFlag{
                Name:  "host-private-key",
                Value: "id_rsa",
                Usage: "path to host private key",
        },
        cli.StringFlag{
                Name:  "server-version",
                Value: "SSH-2.0-gatewaysshd",
                Usage: "ssh server version string",
        },
        cli.StringFlag{
                Name:  "idle-timeout",
                Value: "600s",
                Usage: "ssh connection idle timeout",
        },
        cli.StringFlag{
                Name:  "geoip-database",
                Value: "geoip.mmdb",
                Usage: "path to the geoip database file",
        },
        cli.StringFlag{
                Name:  "postgres-host",
                Value: "127.0.0.1",
                Usage: "host of postgres database",
        },
        cli.UintFlag{
                Name:  "postgres-port",
                Value: 5432,
                Usage: "port of postgres database",
        },
        cli.StringFlag{
                Name:  "postgres-user",
                Value: "gatewaysshd",
                Usage: "user to authenticate with postgres database",
        },
        cli.StringFlag{
                Name:  "postgres-password",
                Value: "gatewaysshd",
                Usage: "password to authenticate with postgres database",
        },
        cli.StringFlag{
                Name:  "postgres-dbname",
                Value: "gatewaysshd",
                Usage: "postgres database name",
        },
}

func parseCaPublicKeys(c *cli.Context) ([]ssh.PublicKey, error) <span class="cov0" title="0">{
        // get the keys
        caPublicKeyRaw, err := os.ReadFile(c.String("ca-public-key"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var caPublicKeys []ssh.PublicKey
        for len(caPublicKeyRaw) &gt; 0 </span><span class="cov0" title="0">{
                caPublicKey, _, _, rest, err := ssh.ParseAuthorizedKey(caPublicKeyRaw)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">caPublicKeys = append(caPublicKeys, caPublicKey)
                caPublicKeyRaw = rest</span>
        }
        <span class="cov0" title="0">return caPublicKeys, nil</span>
}

func parseHostSigner(c *cli.Context) (ssh.Signer, error) <span class="cov0" title="0">{
        // parse host private key
        hostPrivateKeyRaw, err := os.ReadFile(c.String("host-private-key"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">hostPrivateKey, err := ssh.ParsePrivateKey(hostPrivateKeyRaw)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // parse host certificate
        <span class="cov0" title="0">hostPublicKeyRaw, err := os.ReadFile(c.String("host-public-key"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">hostPublicKey, _, _, _, err := ssh.ParseAuthorizedKey(hostPublicKeyRaw)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if hostCertificate, ok := hostPublicKey.(*ssh.Certificate); ok </span><span class="cov0" title="0">{
                hostSigner, err := ssh.NewCertSigner(hostCertificate, hostPrivateKey)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return hostSigner, nil</span>
        }
        <span class="cov0" title="0">return hostPrivateKey, nil</span>
}

func parseIdleTimeout(c *cli.Context) (time.Duration, error) <span class="cov0" title="0">{
        return time.ParseDuration(c.String("idle-timeout"))
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package cli

import (
        "encoding/json"
        "errors"
        "net/http"

        "github.com/gorilla/mux"

        "github.com/ziyan/gatewaysshd/gateway"
)

var (
        ErrNotFound = errors.New("404: not found")
)

func wrapHttpHandler(handler func(*http.Request) (interface{}, error)) func(http.ResponseWriter, *http.Request) <span class="cov0" title="0">{
        return func(response http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                result, err := handler(request)
                if err != nil </span><span class="cov0" title="0">{
                        if err == ErrNotFound </span><span class="cov0" title="0">{
                                http.NotFound(response, request)
                                return
                        }</span>
                        <span class="cov0" title="0">log.Errorf("failed to handle request: %s", err)
                        http.Error(response, "500 internal server error", http.StatusInternalServerError)
                        return</span>
                }
                <span class="cov0" title="0">if handler, ok := result.(http.Handler); ok </span><span class="cov0" title="0">{
                        // allow returned handler to handle the request
                        handler.ServeHTTP(response, request)
                        return
                }</span>
                <span class="cov0" title="0">if handler, ok := result.(http.HandlerFunc); ok </span><span class="cov0" title="0">{
                        // allow returned handler to handle the request
                        handler(response, request)
                        return
                }</span>

                <span class="cov0" title="0">raw, err := json.Marshal(result)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("failed to encode json: %s", err)
                        http.Error(response, "500 internal server error", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">response.Header().Set("Content-Type", "application/json; charset=utf-8")
                _, _ = response.Write(raw)</span>
        }
}

func newHttpHandler(gateway gateway.Gateway) http.Handler <span class="cov0" title="0">{
        router := mux.NewRouter().StrictSlash(true)
        router.Path("/api/user").HandlerFunc(wrapHttpHandler(func(request *http.Request) (interface{}, error) </span><span class="cov0" title="0">{
                return gateway.ListUsers()
        }</span>))
        <span class="cov0" title="0">router.Path("/api/user/{userId}").HandlerFunc(wrapHttpHandler(func(request *http.Request) (interface{}, error) </span><span class="cov0" title="0">{
                user, err := gateway.GetUser(mux.Vars(request)["userId"])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return user, nil</span>
        }))
        <span class="cov0" title="0">router.Path("/api/user/{userId}/screenshot").HandlerFunc(wrapHttpHandler(func(request *http.Request) (interface{}, error) </span><span class="cov0" title="0">{
                screenshot, err := gateway.GetUserScreenshot(mux.Vars(request)["userId"])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if len(screenshot) == 0 </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return http.HandlerFunc(func(response http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                        response.Header().Set("Content-Type", "image/png")
                        _, _ = response.Write(screenshot)
                }</span>), nil
        }))
        <span class="cov0" title="0">return router</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package cli

import (
        "context"
        "fmt"
        "net"
        "net/http"
        "os"
        "os/signal"
        "sync"
        "syscall"
        "time"

        "github.com/urfave/cli"

        "github.com/ziyan/gatewaysshd/auth"
        "github.com/ziyan/gatewaysshd/db"
        "github.com/ziyan/gatewaysshd/gateway"
        "github.com/ziyan/gatewaysshd/util/debugutil"
)

func run(c *cli.Context) error <span class="cov0" title="0">{
        // debugging endpoint, start as early as possible
        if c.String("listen-debug") != "" </span><span class="cov0" title="0">{
                stopDebugServer, err := debugutil.RunDebugServer(c.String("listen-debug"))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer stopDebugServer()</span>
        }

        <span class="cov0" title="0">caPublicKeys, err := parseCaPublicKeys(c)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to parse certificate authority public key from file \"%s\": %s", c.String("ca-public-key"), err)
                return err
        }</span>

        <span class="cov0" title="0">hostSigner, err := parseHostSigner(c)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to host key from file \"%s\" and \"%s\": %s", c.String("host-private-key"), c.String("host-public-key"), err)
                return err
        }</span>

        <span class="cov0" title="0">idleTimeout, err := parseIdleTimeout(c)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to parse idle timeout \"%s\": %s", c.String("idle-timeout"), err)
                return err
        }</span>

        // ssh listener
        <span class="cov0" title="0">log.Debugf("listening ssh endpoint: %s", c.String("listen-ssh"))
        sshListener, err := net.Listen("tcp", c.String("listen-ssh"))
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to listen on %s: %s", c.String("listen-ssh"), err)
                return err
        }</span>

        // http listener
        <span class="cov0" title="0">var httpListener net.Listener
        if c.String("listen-http") != "" </span><span class="cov0" title="0">{
                log.Debugf("listening http endpoint: %s", c.String("listen-http"))
                httpListener, err = net.Listen("tcp", c.String("listen-http"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("failed to listen on %s: %s", c.String("listen-http"), err)
                        return err
                }</span>
        }

        // open database
        <span class="cov0" title="0">pgPort := c.Uint("postgres-port")
        if pgPort &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("postgres port %d is out of range (max 65535)", pgPort)
        }</span>
        <span class="cov0" title="0">database, err := db.Open(c.String("postgres-host"), uint16(pgPort), c.String("postgres-user"), c.String("postgres-password"), c.String("postgres-dbname"))
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to open database: %s", err)
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := database.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Errorf("failed to close database: %s", err)
                }</span>
        }()
        <span class="cov0" title="0">if err := database.Migrate(); err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to migrate database: %s", err)
                return err
        }</span>

        // create ssh auth config
        <span class="cov0" title="0">sshConfig, err := auth.NewConfig(database, caPublicKeys, c.String("geoip-database"))
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to create ssh config: %s", err)
                return err
        }</span>
        <span class="cov0" title="0">sshConfig.ServerVersion = c.String("server-version")
        sshConfig.AddHostKey(hostSigner)

        // create gateway
        gateway, err := gateway.Open(database, sshConfig, &amp;gateway.Settings{
                Version: c.App.Version,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to create ssh gateway: %s", err)
                return err
        }</span>
        <span class="cov0" title="0">defer gateway.Close()

        // run
        var waitGroup sync.WaitGroup

        // accept all connections
        sshRunning := make(chan struct{})
        waitGroup.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer waitGroup.Done()
                defer close(sshRunning)

                log.Debugf("running and serving ssh")
                for </span><span class="cov0" title="0">{
                        socket, err := sshListener.Accept()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Errorf("failed to accept incoming tcp connection: %s", err)
                                break</span>
                        }
                        <span class="cov0" title="0">waitGroup.Add(1)
                        go func() </span><span class="cov0" title="0">{
                                defer waitGroup.Done()
                                gateway.HandleConnection(socket)
                        }</span>()
                }

                <span class="cov0" title="0">log.Debugf("stop serving ssh")</span>
        }()

        // serve http
        <span class="cov0" title="0">var httpServer *http.Server
        httpRunning := make(chan struct{})
        if c.String("listen-http") != "" </span><span class="cov0" title="0">{
                httpServer = &amp;http.Server{
                        Addr:              c.String("listen-http"),
                        Handler:           newHttpHandler(gateway),
                        ReadHeaderTimeout: 30 * time.Second,
                }
                waitGroup.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer waitGroup.Done()
                        defer close(httpRunning)

                        log.Debugf("running and serving http")
                        if err := httpServer.Serve(httpListener); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                                log.Errorf("http server exited with error: %s", err)
                        }</span>

                        <span class="cov0" title="0">log.Debugf("stop serving http")</span>
                }()
        }

        // wait till exit
        <span class="cov0" title="0">signaling := make(chan os.Signal, 2)
        signal.Notify(signaling, syscall.SIGINT, syscall.SIGTERM)

        // signal to quit
        quit := false
        for !quit </span><span class="cov0" title="0">{
                select </span>{
                case sig := &lt;-signaling:<span class="cov0" title="0">
                        log.Warningf("received signal %v", sig)
                        quit = true</span>
                case &lt;-sshRunning:<span class="cov0" title="0">
                        quit = true</span>
                case &lt;-httpRunning:<span class="cov0" title="0">
                        quit = true</span>
                case &lt;-time.After(10 * time.Second):<span class="cov0" title="0">
                        gateway.ScavengeConnections(idleTimeout)</span>
                }
        }

        // make sure there is a deadline on shutting down
        <span class="cov0" title="0">time.AfterFunc(30*time.Second, func() </span><span class="cov0" title="0">{
                log.Fatalf("graceful shutdown server timed out")
                os.Exit(1)
        }</span>)

        // shutdown server, this will block until all connections are closed
        <span class="cov0" title="0">log.Noticef("shutting down")

        waitGroup.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer waitGroup.Done()
                if err := sshListener.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Errorf("failed to close ssh listener: %s", err)
                }</span>
                <span class="cov0" title="0">gateway.Close()</span>
        }()

        <span class="cov0" title="0">if httpServer != nil </span><span class="cov0" title="0">{
                waitGroup.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer waitGroup.Done()
                        if err := httpServer.Shutdown(context.Background()); err != nil </span><span class="cov0" title="0">{
                                log.Errorf("failed to shutdown http server: %s", err)
                        }</span>
                }()
        }

        <span class="cov0" title="0">waitGroup.Wait()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Database
//
// authorities - store certificate authorities, private key, hostname regex
// group - store group, principal regex, principal validity
// user - store user special attributes, such as non-ldap user, groups
// certificates - store signed certificates, key by username/serial
package db

import (
        "fmt"
        "time"

        "github.com/op/go-logging"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

var log = logging.MustGetLogger("db")

type Database interface {
        // migrate database schema
        Migrate() error

        // close opened database
        Close() error

        ListUsers() ([]*User, error)
        GetUser(string) (*User, error)
        PutUser(string, func(*User) error) (*User, error)
}

type database struct {
        db *gorm.DB
}

func Open(host string, port uint16, user, password, dbname string) (Database, error) <span class="cov0" title="0">{
        connection := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=disable", host, port, user, password, dbname)
        db, err := gorm.Open(postgres.Open(connection), &amp;gorm.Config{
                Logger: logger.New(
                        &amp;logWriter{},
                        logger.Config{
                                SlowThreshold:             10 * time.Millisecond,
                                LogLevel:                  logger.Silent,
                                IgnoreRecordNotFoundError: true,
                                Colorful:                  true,
                        },
                ),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">self := &amp;database{
                db: db.Debug(),
        }
        return self, nil</span>
}

func (self *database) Close() error <span class="cov0" title="0">{
        return nil
}</span>

type logWriter struct {
}

func (self *logWriter) Printf(format string, arguments ...interface{}) <span class="cov0" title="0">{
        log.Debugf(format, arguments...)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package db

import (
        "time"

        "gorm.io/gorm"

        "github.com/ziyan/gatewaysshd/db/migrations"
)

// database model for migration records
type Migration struct {
        ID string `gorm:"primary_key:true"`

        Migrated time.Time
}

func (self *Migration) TableName() string <span class="cov0" title="0">{
        return "migration"
}</span>

func (self *database) Migrate() error <span class="cov0" title="0">{
        if err := self.db.AutoMigrate(&amp;Migration{}); err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to migrate database: %s", err)
                return err
        }</span>
        <span class="cov0" title="0">var existingModels []Migration
        if err := self.db.Find(&amp;existingModels).Error; err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to query for migrations: %s", err)
                return err
        }</span>
        <span class="cov0" title="0">existingModelsMap := make(map[string]Migration)
        for _, Migration := range existingModels </span><span class="cov0" title="0">{
                existingModelsMap[Migration.ID] = Migration
        }</span>

        <span class="cov0" title="0">for _, migration := range migrations.Migrations() </span><span class="cov0" title="0">{
                if existingModel, ok := existingModelsMap[migration.ID]; ok </span><span class="cov0" title="0">{
                        log.Debugf("database migration %s already done at %s", migration.ID, existingModel.Migrated)
                        continue</span>
                }
                <span class="cov0" title="0">log.Debugf("migrating database: %s", migration.ID)
                if err := self.db.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                        if err := tx.Exec(migration.SQL).Error; err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if err := tx.Create(&amp;Migration{
                                ID:       migration.ID,
                                Migrated: time.Now().In(time.Local),
                        }).Error; err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }); err != nil <span class="cov0" title="0">{
                        log.Errorf("failed to migrate database: %s: %s", migration.ID, err)
                        return err
                }</span>
                <span class="cov0" title="0">log.Noticef("migrated database: %s", migration.ID)</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package migrations

func init() <span class="cov0" title="0">{
        addMigration("0000_initial", `
                CREATE TABLE IF NOT EXISTS "user" (
                        "id" varchar(256),
                        "created" timestamp with time zone,
                        "modified" timestamp with time zone,
                        "comment" text,
                        "ip" varchar(256),
                        "location" jsonb,
                        "status" jsonb,
                        "disabled" boolean,
                        PRIMARY KEY ("id")
                );
        `)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package migrations

func init() <span class="cov0" title="0">{
        addMigration("0001_add_administrator", `
                ALTER TABLE "user" ADD COLUMN "administrator" boolean;
        `)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package migrations

func init() <span class="cov0" title="0">{
        addMigration("0002_add_screenshot", `
                ALTER TABLE "user" ADD COLUMN "screenshot" bytea;
        `)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package migrations

func init() <span class="cov0" title="0">{
        addMigration("0003_created_at", `
                ALTER TABLE "user" RENAME COLUMN "created" TO "created_at";
                ALTER TABLE "user" RENAME COLUMN "modified" TO "modified_at";
        `)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package migrations

import (
        "sort"
)

var migrations = make(map[string]string)

func addMigration(id, sql string) <span class="cov0" title="0">{
        migrations[id] = sql
}</span>

type Migration struct {
        ID  string
        SQL string
}

// retrieve all registred migrations in this package
func Migrations() []Migration <span class="cov0" title="0">{
        ids := make([]string, 0, len(migrations))
        for id := range migrations </span><span class="cov0" title="0">{
                ids = append(ids, id)
        }</span>
        <span class="cov0" title="0">sort.Strings(ids)

        sortedMigrations := make([]Migration, 0, len(migrations))
        for _, id := range ids </span><span class="cov0" title="0">{
                sortedMigrations = append(sortedMigrations, Migration{
                        ID:  id,
                        SQL: migrations[id],
                })
        }</span>
        <span class="cov0" title="0">return sortedMigrations</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package db

import (
        "database/sql/driver"
        "encoding/json"
        "time"
)

// shared location info
type Location struct {
        Latitude  float64 `json:"latitude,omitempty"`
        Longitude float64 `json:"longitude,omitempty"`
        TimeZone  string  `json:"timezone,omitempty"`
        Country   string  `json:"country,omitempty"`
        City      string  `json:"city,omitempty"`
}

func (self *Location) Scan(value interface{}) error <span class="cov0" title="0">{
        var location Location
        if raw, ok := value.([]byte); ok </span><span class="cov0" title="0">{
                if err := json.Unmarshal(raw, &amp;location); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">*self = location
        return nil</span>
}

func (self Location) Value() (driver.Value, error) <span class="cov0" title="0">{
        return json.Marshal(self)
}</span>

type Status json.RawMessage

func (self *Status) Scan(value interface{}) error <span class="cov0" title="0">{
        var message json.RawMessage
        if raw, ok := value.([]byte); ok </span><span class="cov0" title="0">{
                if err := json.Unmarshal(raw, &amp;message); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">*self = Status(message)
        return nil</span>
}

func (self Status) Value() (driver.Value, error) <span class="cov0" title="0">{
        if len(self) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return json.RawMessage(self).MarshalJSON()</span>
}

func (self Status) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        if len(self) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return json.RawMessage(self).MarshalJSON()</span>
}

// represents a user connected to gateway
type User struct {
        ID string `json:"id,omitempty" gorm:"primary_key:true"`

        // meta data
        CreatedAt  time.Time `json:"createdAt,omitempty"`
        ModifiedAt time.Time `json:"modifiedAt,omitempty"`

        // comments about this user
        Comment string `json:"comment,omitempty"`

        // ip address
        IP string `json:"ip,omitempty"`

        // geo location
        Location Location `json:"location,omitempty" gorm:"type:jsonb"`

        // reported status
        Status Status `json:"status,omitempty"`

        // whether the user is an administrator
        Administrator bool `json:"administrator,omitempty"`

        // screenshot
        Screenshot []byte `json:"-" gorm:"type:bytea"`

        // whether the user account has been disabled
        Disabled bool `json:"disabled,omitempty"`

        // whether the user is online, not saved in database
        Online bool `json:"online,omitempty" gorm:"-"`

        // current connections, not saved in database
        Connections interface{} `json:"connections,omitempty" gorm:"-"`
}

func (self *User) TableName() string <span class="cov0" title="0">{
        return "user"
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package db

import (
        "errors"
        "time"

        "gorm.io/gorm"
)

func (self *database) ListUsers() ([]*User, error) <span class="cov0" title="0">{
        var results []*User
        if err := self.db.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                var models []User
                if err := tx.Select([]string{
                        "id",
                        "created_at",
                        "modified_at",
                        "comment",
                        "ip",
                        "location",
                        "administrator",
                        "disabled",
                }).Find(&amp;models).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">results = make([]*User, 0, len(models))
                for index := range models </span><span class="cov0" title="0">{
                        results = append(results, &amp;models[index])
                }</span>
                <span class="cov0" title="0">return nil</span>
        }); err != nil <span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return results, nil</span>
}

func (self *database) GetUser(userId string) (*User, error) <span class="cov0" title="0">{
        var result *User
        if err := self.db.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                var model User
                if err := tx.Where("id = ?", userId).First(&amp;model).Error; err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov0" title="0">result = &amp;model
                return nil</span>
        }); err != nil <span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (self *database) PutUser(userId string, modifier func(*User) error) (*User, error) <span class="cov0" title="0">{
        var result *User
        if err := self.db.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                var create bool
                var model User
                if err := tx.Where("id = ?", userId).First(&amp;model).Error; err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                                create = true
                        }</span> else<span class="cov0" title="0"> {
                                return err
                        }</span>
                }
                <span class="cov0" title="0">if err := modifier(&amp;model); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">model.ID = userId
                now := time.Now().In(time.Local)
                if create </span><span class="cov0" title="0">{
                        model.CreatedAt = now
                }</span>
                <span class="cov0" title="0">model.ModifiedAt = now
                if create </span><span class="cov0" title="0">{
                        if err := tx.Create(&amp;model).Error; err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        if err := tx.Save(&amp;model).Error; err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">result = &amp;model
                return nil</span>
        }); err != nil <span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package gateway

import (
        "encoding/json"
        "errors"
        "fmt"
        "net"
        "sync"
        "time"

        "github.com/segmentio/ksuid"
        "golang.org/x/crypto/ssh"

        "github.com/ziyan/gatewaysshd/db"
)

var (
        ErrServiceAlreadyRegistered = errors.New("gateway: service already registered")
        ErrServiceNotFound          = errors.New("gateway: service not found")
        ErrExtraDataNotAllowed      = errors.New("gateway: extra data not allowed")
        ErrUnknownChannelType       = errors.New("gateway: unknown channel type")
        ErrPermissionDenied         = errors.New("gateway: permission denied")
)

// a ssh connection
type connection struct {
        id                   string
        gateway              *gateway
        conn                 *ssh.ServerConn
        user                 string
        remoteAddr           net.Addr
        localAddr            net.Addr
        tunnels              []*tunnel
        tunnelsOpened        uint64
        tunnelsClosed        uint64
        services             map[string]map[uint16]bool
        done                 chan struct{}
        lock                 sync.Mutex
        waitGroup            sync.WaitGroup
        usage                *usageStats
        permitPortForwarding bool
        administrator        bool
}

func handleConnection(gateway *gateway, conn *ssh.ServerConn, channels &lt;-chan ssh.NewChannel, requests &lt;-chan *ssh.Request, usage *usageStats) <span class="cov0" title="0">{
        permitPortForwarding := false
        if _, ok := conn.Permissions.Extensions["permit-port-forwarding"]; ok </span><span class="cov0" title="0">{
                permitPortForwarding = true
        }</span>

        <span class="cov0" title="0">administrator := false
        if _, ok := conn.Permissions.Extensions["administrator"]; ok </span><span class="cov0" title="0">{
                administrator = true
        }</span>

        <span class="cov0" title="0">self := &amp;connection{
                id:                   ksuid.New().String(),
                gateway:              gateway,
                conn:                 conn,
                user:                 conn.User(),
                remoteAddr:           conn.RemoteAddr(),
                localAddr:            conn.LocalAddr(),
                services:             make(map[string]map[uint16]bool),
                usage:                usage,
                permitPortForwarding: permitPortForwarding,
                administrator:        administrator,
                done:                 make(chan struct{}),
        }
        log.Infof("%s: new connection", self)
        self.gateway.addConnection(self)

        // handle requests and channels on this connection
        self.waitGroup.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer self.waitGroup.Done()
                defer func() </span><span class="cov0" title="0">{
                        self.gateway.deleteConnection(self)
                        if err := self.conn.Close(); err != nil </span><span class="cov0" title="0">{
                                log.Warningf("%s: failed to close connection: %s", self, err)
                        }</span>
                        <span class="cov0" title="0">log.Infof("%s: connection closed", self)</span>
                }()

                <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-self.done:<span class="cov0" title="0">
                                return</span>
                        case request, ok := &lt;-requests:<span class="cov0" title="0">
                                if !ok </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">if err := self.handleRequest(request); err != nil </span><span class="cov0" title="0">{
                                        log.Warningf("%s: failed to handle request: %s", self, err)
                                        return
                                }</span>
                        case channel, ok := &lt;-channels:<span class="cov0" title="0">
                                if !ok </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">if err := self.handleChannel(channel); err != nil </span><span class="cov0" title="0">{
                                        log.Warningf("%s: failed to handle channel: %s", self, err)
                                        return
                                }</span>
                        }
                }
        }()
}

func (self *connection) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("connection(id=%q, remote=%q, user=%q)", self.id, self.remoteAddr, self.user)
}</span>

// close the ssh connection
func (self *connection) close() <span class="cov0" title="0">{
        defer self.waitGroup.Wait()
        close(self.done)
        log.Debugf("%s: connection closed", self)
}</span>

// tunnels within a ssh connection
// func (self *connection) listTunnels() []*tunnel {
//         self.lock.Lock()
//         defer self.lock.Unlock()

//         tunnels := make([]*tunnel, len(self.tunnels))
//         copy(tunnels, self.tunnels)
//         return tunnels
// }

func (self *connection) addTunnel(t *tunnel) <span class="cov0" title="0">{
        self.lock.Lock()
        defer self.lock.Unlock()

        self.tunnels = append([]*tunnel{t}, self.tunnels...)
        self.tunnelsOpened += 1
}</span>

func (self *connection) deleteTunnel(t *tunnel) <span class="cov0" title="0">{
        self.lock.Lock()
        defer self.lock.Unlock()

        // filter the list of channels
        tunnels := make([]*tunnel, 0, len(self.tunnels))
        for _, tunnel := range self.tunnels </span><span class="cov0" title="0">{
                if tunnel != t </span><span class="cov0" title="0">{
                        tunnels = append(tunnels, tunnel)
                }</span>
        }
        <span class="cov0" title="0">self.tunnels = tunnels
        self.tunnelsClosed += 1</span>
}

// returns the last used time of the connection
func (self *connection) getUsedAt() time.Time <span class="cov0" title="0">{
        self.lock.Lock()
        defer self.lock.Unlock()

        return self.usage.usedAt
}</span>

// returns the list of services this connection advertises
// func (self *connection) listServices() map[string][]uint16 {
//         self.lock.Lock()
//         defer self.lock.Unlock()

//         services := make(map[string][]uint16)
//         for host, ports := range self.services {
//                 for port, ok := range ports {
//                         if ok {
//                                 services[host] = append(services[host], port)
//                         }
//                 }
//         }

//         return services
// }

func (self *connection) reportStatus(status json.RawMessage) error <span class="cov0" title="0">{
        if _, err := self.gateway.database.PutUser(self.user, func(model *db.User) error </span><span class="cov0" title="0">{
                model.Status = db.Status(status)
                return nil
        }</span>); err != nil <span class="cov0" title="0">{
                log.Errorf("%s: failed to save user in database: %s", self, err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (self *connection) reportScreenshot(screenshot []byte) error <span class="cov0" title="0">{
        if _, err := self.gateway.database.PutUser(self.user, func(model *db.User) error </span><span class="cov0" title="0">{
                model.Screenshot = screenshot
                return nil
        }</span>); err != nil <span class="cov0" title="0">{
                log.Errorf("%s: failed to save user in database: %s", self, err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type connectionStatus struct {
        ID string `json:"id,omitempty"`

        CreatedAt time.Time `json:"createdAt,omitempty"`
        UsedAt    time.Time `json:"usedAt,omitempty"`

        User                 string `json:"user,omitempty"`
        Administrator        bool   `json:"administrator,omitempty"`
        PermitPortForwarding bool   `json:"permitPortForwarding,omitempty"`
        Address              string `json:"address,omitempty"`

        Tunnels       []*tunnelStatus `json:"tunnels,omitempty"`
        TunnelsActive uint64          `json:"tunnelsActive,omitempty"`
        TunnelsOpened uint64          `json:"tunnelsOpened,omitempty"`
        TunnelsClosed uint64          `json:"tunnelsClosed,omitempty"`

        UpTime   uint64 `json:"upTime"`
        IdleTime uint64 `json:"idleTime"`

        BytesRead    uint64 `json:"bytesRead"`
        BytesWritten uint64 `json:"bytesWritten"`

        Services map[string][]uint16 `json:"services,omitempty"`
}

func (self *connection) gatherStatus() *connectionStatus <span class="cov0" title="0">{
        self.lock.Lock()
        defer self.lock.Unlock()

        // services
        services := make(map[string][]uint16)
        for host, ports := range self.services </span><span class="cov0" title="0">{
                for port, ok := range ports </span><span class="cov0" title="0">{
                        if ok </span><span class="cov0" title="0">{
                                services[host] = append(services[host], port)
                        }</span>
                }
        }

        <span class="cov0" title="0">tunnels := make([]*tunnelStatus, 0, len(self.tunnels))
        for _, tunnel := range self.tunnels </span><span class="cov0" title="0">{
                tunnels = append(tunnels, tunnel.gatherStatus())
        }</span>

        <span class="cov0" title="0">return &amp;connectionStatus{
                ID:                   self.id,
                User:                 self.user,
                Administrator:        self.administrator,
                PermitPortForwarding: self.permitPortForwarding,
                Address:              self.remoteAddr.String(),
                Tunnels:              tunnels,
                TunnelsActive:        uint64(len(tunnels)),
                TunnelsOpened:        self.tunnelsOpened,
                TunnelsClosed:        self.tunnelsClosed,
                CreatedAt:            self.usage.createdAt,
                UsedAt:               self.usage.usedAt,
                UpTime:               uint64(time.Since(self.usage.createdAt).Seconds()),
                IdleTime:             uint64(time.Since(self.usage.usedAt).Seconds()),
                BytesRead:            self.usage.bytesRead,
                BytesWritten:         self.usage.bytesWritten,
                Services:             services,
        }</span>
}

func (self *connection) lookupService(host string, port uint16) bool <span class="cov0" title="0">{
        self.lock.Lock()
        defer self.lock.Unlock()

        if _, ok := self.services[host]; !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return self.services[host][port]</span>
}

func (self *connection) registerService(host string, port uint16) error <span class="cov0" title="0">{
        self.lock.Lock()
        defer self.lock.Unlock()

        if _, ok := self.services[host]; !ok </span><span class="cov0" title="0">{
                self.services[host] = make(map[uint16]bool)
        }</span>
        <span class="cov0" title="0">if self.services[host][port] </span><span class="cov0" title="0">{
                return ErrServiceAlreadyRegistered
        }</span>
        <span class="cov0" title="0">self.services[host][port] = true

        log.Debugf("%s: registered service: host = %s, port = %d", self, host, port)
        return nil</span>
}

func (self *connection) deregisterService(host string, port uint16) error <span class="cov0" title="0">{
        self.lock.Lock()
        defer self.lock.Unlock()

        if _, ok := self.services[host]; ok </span><span class="cov0" title="0">{
                delete(self.services[host], port)
        }</span>

        <span class="cov0" title="0">log.Debugf("%s: deregistered service: host = %s, port = %d", self, host, port)
        return nil</span>
}

func (self *connection) handleRequest(request *ssh.Request) error <span class="cov0" title="0">{
        // log.Debugf("request received: type = %s, want_reply = %v, payload = %d", request.Type, request.WantReply, len(request.Payload))

        ok := false
        switch request.Type </span>{
        case "tcpip-forward":<span class="cov0" title="0">
                request, err := unmarshalForwardRequest(request.Payload)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("%s: failed to decode request: %s", self, err)
                        return err
                }</span>

                <span class="cov0" title="0">if request.Port == 0 </span><span class="cov0" title="0">{
                        log.Errorf("%s: requested forwarding port is not allowed: %d", self, request.Port)
                        return err
                }</span>

                <span class="cov0" title="0">if request.Port &gt; 65535 </span><span class="cov0" title="0">{
                        return fmt.Errorf("port %d is out of range (max 65535)", request.Port)
                }</span>
                <span class="cov0" title="0">if err := self.registerService(request.Host, uint16(request.Port)); err != nil </span><span class="cov0" title="0">{
                        log.Errorf("%s: failed to register service in connection: %s", self, err)
                        return err
                }</span>

                <span class="cov0" title="0">ok = true</span>
        case "cancel-tcpip-forward":<span class="cov0" title="0">
                request, err := unmarshalForwardRequest(request.Payload)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("%s: failed to decode request: %s", self, err)
                        return err
                }</span>

                <span class="cov0" title="0">if request.Port &gt; 65535 </span><span class="cov0" title="0">{
                        return fmt.Errorf("port %d is out of range (max 65535)", request.Port)
                }</span>
                <span class="cov0" title="0">if err := self.deregisterService(request.Host, uint16(request.Port)); err != nil </span><span class="cov0" title="0">{
                        log.Errorf("%s: failed to register service in connection: %s", self, err)
                        return err
                }</span>

                <span class="cov0" title="0">ok = true</span>
        }
        <span class="cov0" title="0">if request.WantReply </span><span class="cov0" title="0">{
                if err := request.Reply(ok, nil); err != nil </span><span class="cov0" title="0">{
                        log.Errorf("%s: failed to reply to request: %s", self, err)
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (self *connection) handleChannel(newChannel ssh.NewChannel) error <span class="cov0" title="0">{
        log.Debugf("%s: new channel: type = %s, data = %v", self, newChannel.ChannelType(), newChannel.ExtraData())

        ok := false
        rejection := ssh.UnknownChannelType
        message := "unknown channel type"
        err := ErrUnknownChannelType

        switch newChannel.ChannelType() </span>{
        case "session":<span class="cov0" title="0">
                ok, rejection, message, err = self.handleSessionChannel(newChannel)</span>
        case "direct-tcpip":<span class="cov0" title="0">
                ok, rejection, message, err = self.handleTunnelChannel(newChannel)</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">log.Debugf("%s: channel rejected due to %d: %s", self, rejection, message)

        // reject the channel, by accepting it then immediately close
        // this is because Reject() leaks
        channel, requests, err := newChannel.Accept()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("%s: failed to reject channel: %s", self, err)
                return err
        }</span>

        <span class="cov0" title="0">self.waitGroup.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer self.waitGroup.Done()
                ssh.DiscardRequests(requests)
        }</span>()

        <span class="cov0" title="0">if err := channel.Close(); err != nil </span><span class="cov0" title="0">{
                log.Errorf("%s: failed to close rejected channel: %s", self, err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (self *connection) handleSessionChannel(newChannel ssh.NewChannel) (bool, ssh.RejectionReason, string, error) <span class="cov0" title="0">{
        if len(newChannel.ExtraData()) &gt; 0 </span><span class="cov0" title="0">{
                // do not accept extra data in connection channel request
                return false, ssh.Prohibited, "extra data not allowed", ErrExtraDataNotAllowed
        }</span>

        // accept the channel
        <span class="cov0" title="0">channel, requests, err := newChannel.Accept()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("%s: failed to accept channel: %s", self, err)
                return true, 0, "", err
        }</span>

        // cannot return false from this point on
        <span class="cov0" title="0">self.waitGroup.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer self.waitGroup.Done()
                handleSession(self, channel, requests, newChannel.ChannelType(), newChannel.ExtraData())
        }</span>()
        <span class="cov0" title="0">return true, 0, "", nil</span>
}

func (self *connection) handleTunnelChannel(newChannel ssh.NewChannel) (bool, ssh.RejectionReason, string, error) <span class="cov0" title="0">{
        data, err := unmarshalTunnelData(newChannel.ExtraData())
        if err != nil </span><span class="cov0" title="0">{
                return false, ssh.UnknownChannelType, "failed to decode extra data", err
        }</span>

        // see if this connection is allowed
        <span class="cov0" title="0">if !self.permitPortForwarding </span><span class="cov0" title="0">{
                log.Errorf("%s: no permission to port forward", self)
                return false, ssh.Prohibited, "permission denied", ErrPermissionDenied
        }</span>

        // look up connection by name
        <span class="cov0" title="0">if data.Port &gt; 65535 </span><span class="cov0" title="0">{
                return false, ssh.ConnectionFailed, fmt.Sprintf("port %d is out of range (max 65535)", data.Port), nil
        }</span>
        <span class="cov0" title="0">portU16 := uint16(data.Port) // #nosec G115 - safe: checked above for range
        otherConnection, host, port := self.gateway.lookupConnectionService(data.Host, portU16)
        if otherConnection == nil </span><span class="cov0" title="0">{
                return false, ssh.ConnectionFailed, "service not found or not online", nil
        }</span>

        // accept the channel
        <span class="cov0" title="0">channel, requests, err := newChannel.Accept()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("%s: failed to accept channel: %s", self, err)
                return true, 0, "", err
        }</span>

        <span class="cov0" title="0">self.waitGroup.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer self.waitGroup.Done()

                // first need to track the opened channel
                thisTunnel := newTunnel(self, channel, newChannel.ChannelType(), newChannel.ExtraData(), map[string]interface{}{
                        "origin": data.OriginAddress,
                        "to": map[string]interface{}{
                                "user":    otherConnection.user,
                                "address": otherConnection.remoteAddr.String(),
                        },
                        "service": map[string]interface{}{
                                "host": data.Host,
                                "port": data.Port,
                        },
                })
                self.waitGroup.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer self.waitGroup.Done()
                        thisTunnel.handleRequests(requests)
                }</span>()
                <span class="cov0" title="0">defer thisTunnel.close()

                // attempt to open a channel, this can block
                otherTunnel, err := otherConnection.openTunnel("forwarded-tcpip", marshalTunnelData(&amp;tunnelData{
                        Host:          host,
                        Port:          uint32(port),
                        OriginAddress: data.OriginAddress,
                        OriginPort:    data.OriginPort,
                }), map[string]interface{}{
                        "origin": data.OriginAddress,
                        "from": map[string]interface{}{
                                "address": self.remoteAddr.String(),
                                "user":    self.user,
                        },
                        "service": map[string]interface{}{
                                "host": data.Host,
                                "port": data.Port,
                        },
                })
                if err != nil </span><span class="cov0" title="0">{
                        log.Warningf("%s: failed to open tunnel to %s: %s", self, otherConnection, err)
                        return
                }</span>
                <span class="cov0" title="0">defer otherTunnel.close()

                thisTunnel.handleTunnel(otherTunnel)</span>
        }()
        <span class="cov0" title="0">return true, 0, "", nil</span>
}

// open a channel from the server to the client side
func (self *connection) openTunnel(channelType string, extraData []byte, metadata map[string]interface{}) (*tunnel, error) <span class="cov0" title="0">{
        log.Debugf("%s: opening channel: type = %s, data = %v", self, channelType, extraData)

        channel, requests, err := self.conn.OpenChannel(channelType, extraData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // no failure
        <span class="cov0" title="0">tunnel := newTunnel(self, channel, channelType, extraData, metadata)
        self.waitGroup.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer self.waitGroup.Done()
                tunnel.handleRequests(requests)
        }</span>()
        <span class="cov0" title="0">return tunnel, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package gateway

import (
        "net"
        "strings"
        "sync"
        "time"

        "github.com/op/go-logging"
        "golang.org/x/crypto/ssh"

        "github.com/ziyan/gatewaysshd/db"
)

var log = logging.MustGetLogger("gateway")

type Settings struct {
        Version string
}

// an instance of gateway, contains runtime states
type Gateway interface {
        Close()

        HandleConnection(net.Conn)
        ScavengeConnections(time.Duration)

        ListUsers() (interface{}, error)
        GetUser(string) (interface{}, error)
        GetUserScreenshot(string) ([]byte, error)
}

type gateway struct {
        database         db.Database
        sshConfig        *ssh.ServerConfig
        settings         *Settings
        connectionsIndex map[string][]*connection
        connectionsList  []*connection
        lock             sync.Mutex
}

// creates a new instance of gateway
func Open(database db.Database, sshConfig *ssh.ServerConfig, settings *Settings) (Gateway, error) <span class="cov0" title="0">{
        return &amp;gateway{
                database:         database,
                sshConfig:        sshConfig,
                settings:         settings,
                connectionsIndex: make(map[string][]*connection),
                connectionsList:  make([]*connection, 0),
        }, nil
}</span>

// close the gateway instance
func (self *gateway) Close() <span class="cov0" title="0">{
        for _, connection := range self.listConnections() </span><span class="cov0" title="0">{
                connection.close()
        }</span>
}

// handle an incoming ssh connection
func (self *gateway) HandleConnection(c net.Conn) <span class="cov0" title="0">{
        log.Infof("new tcp connection: remote = %s, local = %s", c.RemoteAddr(), c.LocalAddr())
        defer func() </span><span class="cov0" title="0">{
                if c != nil </span><span class="cov0" title="0">{
                        if err := c.Close(); err != nil </span><span class="cov0" title="0">{
                                log.Warningf("failed to close connection: %s", err)
                        }</span>
                }
        }()

        <span class="cov0" title="0">usage := newUsage()
        conn, channels, requests, err := ssh.NewServerConn(wrapConn(c, usage), self.sshConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Warningf("failed during ssh handshake: %s", err)
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if conn != nil </span><span class="cov0" title="0">{
                        if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                                log.Warningf("failed to close connection: %s", err)
                        }</span>
                }
        }()

        // create a connection and handle it
        <span class="cov0" title="0">handleConnection(self, conn, channels, requests, usage)

        // don't close connection on success
        conn = nil
        c = nil</span>
}

// add connection to the list of connections
func (self *gateway) addConnection(c *connection) <span class="cov0" title="0">{
        self.lock.Lock()
        defer self.lock.Unlock()

        self.connectionsIndex[c.user] = append([]*connection{c}, self.connectionsIndex[c.user]...)
        self.connectionsList = append([]*connection{c}, self.connectionsList...)
}</span>

func (self *gateway) deleteConnection(c *connection) <span class="cov0" title="0">{
        self.lock.Lock()
        defer self.lock.Unlock()

        connections := make([]*connection, 0, len(self.connectionsIndex[c.user]))
        for _, connection := range self.connectionsIndex[c.user] </span><span class="cov0" title="0">{
                if connection != c </span><span class="cov0" title="0">{
                        connections = append(connections, connection)
                }</span>
        }
        <span class="cov0" title="0">self.connectionsIndex[c.user] = connections

        connections = make([]*connection, 0, len(self.connectionsList))
        for _, connection := range self.connectionsList </span><span class="cov0" title="0">{
                if connection != c </span><span class="cov0" title="0">{
                        connections = append(connections, connection)
                }</span>
        }
        <span class="cov0" title="0">self.connectionsList = connections</span>
}

func (self *gateway) lookupConnectionService(host string, port uint16) (*connection, string, uint16) <span class="cov0" title="0">{
        self.lock.Lock()
        defer self.lock.Unlock()

        parts := strings.Split(host, ".")
        for i := range parts </span><span class="cov0" title="0">{
                host := strings.Join(parts[:i], ".")
                user := strings.Join(parts[i:], ".")

                for _, connection := range self.connectionsIndex[user] </span><span class="cov0" title="0">{
                        if connection.lookupService(host, port) </span><span class="cov0" title="0">{
                                log.Debugf("lookup: found service: connection = %s, host = %s, port = %d", connection, host, port)
                                return connection, host, port
                        }</span>
                }
        }

        <span class="cov0" title="0">log.Debugf("lookup: failed to find service: host = %s, port = %d", host, port)
        return nil, "", 0</span>
}

// returns a list of connections
func (self *gateway) listConnections() []*connection <span class="cov0" title="0">{
        self.lock.Lock()
        defer self.lock.Unlock()

        connections := make([]*connection, len(self.connectionsList))
        copy(connections, self.connectionsList)
        return connections
}</span>

// scavenge timed out connections
func (self *gateway) ScavengeConnections(timeout time.Duration) <span class="cov0" title="0">{
        for _, connection := range self.listConnections() </span><span class="cov0" title="0">{
                idle := time.Since(connection.getUsedAt())
                if idle &gt; timeout </span><span class="cov0" title="0">{
                        log.Infof("scavenge: connection %s timed out after %s", connection, idle)
                        connection.close()
                }</span>
        }
}

func (self *gateway) kickUser(user string) error <span class="cov0" title="0">{
        for _, connection := range self.listConnections() </span><span class="cov0" title="0">{
                if connection.user == user </span><span class="cov0" title="0">{
                        log.Infof("kick: closing connection %s", connection)
                        connection.close()
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (self *gateway) gatherStatus(user string) map[string]interface{} <span class="cov0" title="0">{
        self.lock.Lock()
        defer self.lock.Unlock()

        connections := make([]interface{}, 0, len(self.connectionsList))
        for _, connection := range self.connectionsList </span><span class="cov0" title="0">{
                if user == "" || connection.user == user </span><span class="cov0" title="0">{
                        connections = append(connections, connection.gatherStatus())
                }</span>
        }

        <span class="cov0" title="0">return map[string]interface{}{
                "connections": connections,
        }</span>
}

func (self *gateway) ListUsers() (interface{}, error) <span class="cov0" title="0">{
        users, err := self.database.ListUsers()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">func() </span><span class="cov0" title="0">{
                self.lock.Lock()
                defer self.lock.Unlock()
                for _, user := range users </span><span class="cov0" title="0">{
                        user.Status = nil
                        user.Online = false
                        for _, connection := range self.connectionsList </span><span class="cov0" title="0">{
                                if connection.user == user.ID </span><span class="cov0" title="0">{
                                        user.Online = true
                                        break</span>
                                }
                        }
                }
        }()
        <span class="cov0" title="0">return map[string]interface{}{
                "users": users,
                "meta": map[string]interface{}{
                        "totalCount": len(users),
                },
        }, nil</span>
}

func (self *gateway) GetUser(userId string) (interface{}, error) <span class="cov0" title="0">{
        user, err := self.database.GetUser(userId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">var connections []*connectionStatus
        func() </span><span class="cov0" title="0">{
                self.lock.Lock()
                defer self.lock.Unlock()

                for _, connection := range self.connectionsList </span><span class="cov0" title="0">{
                        if connection.user == user.ID </span><span class="cov0" title="0">{
                                connections = append(connections, connection.gatherStatus())
                        }</span>
                }
        }()

        <span class="cov0" title="0">user.Online = len(connections) &gt; 0
        user.Connections = connections

        return map[string]interface{}{
                "user": user,
        }, nil</span>
}

func (self *gateway) GetUserScreenshot(userId string) ([]byte, error) <span class="cov0" title="0">{
        user, err := self.database.GetUser(userId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return user.Screenshot, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package gateway

import (
        "compress/gzip"
        "encoding/json"
        "errors"
        "fmt"
        "io"

        "strings"
        "time"

        "golang.org/x/crypto/ssh"
        "golang.org/x/term"
)

var (
        ErrInvalidCommand = errors.New("gateway: invalid command")
        ErrNotFound       = errors.New("gateway: not found")
)

type service struct {
        connection *connection
        channel    ssh.Channel
        terminal   *term.Terminal
}

func runService(command string, connection *connection, channel ssh.Channel) error <span class="cov0" title="0">{
        self := &amp;service{
                connection: connection,
                channel:    channel,
        }
        if len(command) == 0 </span><span class="cov0" title="0">{
                self.terminal = term.NewTerminal(channel, "")
                return self.handleShell()
        }</span>
        <span class="cov0" title="0">if err := self.handleCommand(splitCommand(command)); err != nil </span><span class="cov0" title="0">{
                if err == ErrInvalidCommand </span><span class="cov0" title="0">{
                        // legacy behavior, command itself is json
                        var status json.RawMessage
                        if err := json.Unmarshal([]byte(command), &amp;status); err != nil </span><span class="cov0" title="0">{
                                log.Errorf("%s: failed to unmarshal json: %s", self.connection, err)
                                return err
                        }</span>
                        <span class="cov0" title="0">return self.connection.reportStatus(status)</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// func (self *service) unmarshal(v interface{}) error {
//         input, err := self.read("json&gt; ")
//         if err != nil {
//                 return err
//         }
//         if err := json.Unmarshal(input, v); err != nil {
//                 return err
//         }
//         return nil
// }

func (self *service) marshal(v interface{}) error <span class="cov0" title="0">{
        output, err := json.MarshalIndent(v, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return self.write(append(output, byte('\n')))</span>
}

// func (self *service) read(prompt string) ([]byte, error) {
//         if self.terminal != nil {
//                 self.terminal.SetPrompt(prompt)
//                 line, err := self.terminal.ReadLine()
//                 if err != nil {
//                         return nil, err
//                 }
//                 return []byte(line), nil
//         }
//         return ioutil.ReadAll(self.channel)
// }

func (self *service) write(data []byte) error <span class="cov0" title="0">{
        if self.terminal != nil </span><span class="cov0" title="0">{
                if _, err := self.terminal.Write(data); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">if _, err := self.channel.Write(data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (self *service) handleShell() error <span class="cov0" title="0">{
        if err := self.write([]byte(fmt.Sprintf("Welcome to gatewaysshd version %s! Type \"help\" to get a list of available commands.\n", self.connection.gateway.settings.Version))); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                self.terminal.SetPrompt("gatewaysshd&gt; ")
                line, err := self.terminal.ReadLine()
                if err == io.EOF </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">line = strings.TrimSpace(line)
                if len(line) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">switch line </span>{
                case "exit", "quit":<span class="cov0" title="0">
                        return nil</span>
                }
                <span class="cov0" title="0">if err := self.handleCommand(splitCommand(line)); err != nil </span><span class="cov0" title="0">{
                        if _, err := self.terminal.Write([]byte(fmt.Sprintf("ERROR: %s\n", err))); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
        }
}

func (self *service) handleCommand(command []string) error <span class="cov0" title="0">{
        switch </span>{
        case len(command) == 1 &amp;&amp; command[0] == "help":<span class="cov0" title="0">
                return self.help()</span>
        case len(command) == 1 &amp;&amp; command[0] == "ping":<span class="cov0" title="0">
                return self.ping()</span>
        case len(command) == 1 &amp;&amp; command[0] == "version":<span class="cov0" title="0">
                return self.version()</span>
        case len(command) == 1 &amp;&amp; command[0] == "reportStatus":<span class="cov0" title="0">
                return self.reportStatus()</span>
        case len(command) == 1 &amp;&amp; command[0] == "reportScreenshot":<span class="cov0" title="0">
                return self.reportScreenshot()</span>
        }

        <span class="cov0" title="0">if !self.connection.permitPortForwarding </span><span class="cov0" title="0">{
                return ErrInvalidCommand
        }</span>

        <span class="cov0" title="0">switch </span>{
        case len(command) == 1 &amp;&amp; command[0] == "status":<span class="cov0" title="0">
                return self.status("")</span>
        case len(command) == 2 &amp;&amp; command[0] == "status":<span class="cov0" title="0">
                return self.status(command[1])</span>
        case len(command) == 1 &amp;&amp; command[0] == "listUsers":<span class="cov0" title="0">
                return self.listUsers()</span>
        case len(command) == 2 &amp;&amp; command[0] == "getUser":<span class="cov0" title="0">
                return self.getUser(command[1])</span>
        }

        <span class="cov0" title="0">if !self.connection.administrator </span><span class="cov0" title="0">{
                return ErrInvalidCommand
        }</span>
        <span class="cov0" title="0">switch </span>{
        case len(command) == 2 &amp;&amp; command[0] == "kickUser":<span class="cov0" title="0">
                return self.kickUser(command[1])</span>
        }
        <span class="cov0" title="0">return ErrInvalidCommand</span>
}

func (self *service) help() error <span class="cov0" title="0">{
        content := []string{
                "Available commands:",
                "",
        }

        if self.connection.permitPortForwarding </span><span class="cov0" title="0">{
                content = append(content, []string{
                        "    status [username] - show gateway status, optionally filter by username",
                        "    listUsers - list all users in database",
                        "    getUser &lt;username&gt; - get details about a user from database",
                        "",
                }...)
        }</span>

        <span class="cov0" title="0">if self.connection.administrator </span><span class="cov0" title="0">{
                content = append(content, []string{
                        "    kickUser &lt;username&gt; - close connections from a user",
                        "",
                }...)
        }</span>

        <span class="cov0" title="0">content = append(content, []string{
                "    exit - exit shell",
                "    quit - same as exit",
                "    help - display this help message",
                "    version - show server version",
                "    ping - ping server",
                "",
                "",
        }...)
        return self.write([]byte(strings.Join(content, "\n")))</span>
}

func (self *service) ping() error <span class="cov0" title="0">{
        data, err := json.Marshal(map[string]interface{}{
                "version": self.connection.gateway.settings.Version,
                "services": []string{
                        "ping",
                        "reportStatus",
                        "reportScreenshot",
                },
                "now": time.Now().In(time.Local),
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := self.write(data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return self.write([]byte("\n"))</span>
}

func (self *service) version() error <span class="cov0" title="0">{
        return self.write([]byte(fmt.Sprintf("%s\n", self.connection.gateway.settings.Version)))
}</span>

func (self *service) status(user string) error <span class="cov0" title="0">{
        var status interface{}
        if !self.connection.permitPortForwarding </span><span class="cov0" title="0">{
                status = self.connection.gatherStatus()
        }</span> else<span class="cov0" title="0"> {
                status = self.connection.gateway.gatherStatus(user)
        }</span>
        <span class="cov0" title="0">return self.marshal(status)</span>
}

func (self *service) reportStatus() error <span class="cov0" title="0">{
        if self.terminal != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("gateway: this command cannot be run in shell")
        }</span>

        <span class="cov0" title="0">reader, err := gzip.NewReader(self.channel)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("%s: failed to decompress: %s", self, err)
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := reader.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Warningf("failed to close reader: %v", err)
                }</span>
        }()

        // read all data from session
        <span class="cov0" title="0">raw, err := io.ReadAll(reader)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("%s: failed to read all: %s", self, err)
                return err
        }</span>

        // parse it in to json
        <span class="cov0" title="0">var status json.RawMessage
        if err := json.Unmarshal(raw, &amp;status); err != nil </span><span class="cov0" title="0">{
                log.Errorf("%s: failed to unmarshal json: %s", self, err)
                return err
        }</span>

        // save the result
        <span class="cov0" title="0">return self.connection.reportStatus(status)</span>
}

func (self *service) reportScreenshot() error <span class="cov0" title="0">{
        if self.terminal != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("gateway: this command cannot be run in shell")
        }</span>

        // read all data from session
        <span class="cov0" title="0">screenshot, err := io.ReadAll(self.channel)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("%s: failed to read all: %s", self, err)
                return err
        }</span>

        // save the result
        <span class="cov0" title="0">return self.connection.reportScreenshot(screenshot)</span>
}

func (self *service) listUsers() error <span class="cov0" title="0">{
        output, err := self.connection.gateway.ListUsers()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return self.marshal(output)</span>
}

func (self *service) getUser(userId string) error <span class="cov0" title="0">{
        output, err := self.connection.gateway.GetUser(userId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return self.marshal(output)</span>
}

func (self *service) kickUser(userId string) error <span class="cov0" title="0">{
        if err := self.connection.gateway.kickUser(userId); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package gateway

import (
        "fmt"

        "golang.org/x/crypto/ssh"
)

// handle session within a ssh connection
func handleSession(connection *connection, channel ssh.Channel, requests &lt;-chan *ssh.Request, channelType string, extraData []byte) <span class="cov0" title="0">{
        log.Debugf("%s: new session: type = %s", connection, channelType)

        // hanlde requests
        for request := range requests </span><span class="cov0" title="0">{
                // log.Debugf("%s: request received: type = %s, want_reply = %v, payload = %d", connection, request.Type, request.WantReply, len(request.Payload))

                // check parameters
                ok := true
                switch request.Type </span>{
                case "env":<span class="cov0" title="0"></span>
                        // just ignore the env settings from client
                case "shell":<span class="cov0" title="0"></span>
                        // allow creating shell
                case "exec":<span class="cov0" title="0"></span>
                        // allow execute command
                case "pty-req":<span class="cov0" title="0"></span>
                        // allow pty
                default:<span class="cov0" title="0">
                        ok = false</span>
                }

                // reply to client
                <span class="cov0" title="0">if request.WantReply </span><span class="cov0" title="0">{
                        if err := request.Reply(ok, nil); err != nil </span><span class="cov0" title="0">{
                                log.Errorf("%s: failed to reply to request: %s", connection, err)
                                break</span>
                        }
                }

                <span class="cov0" title="0">switch request.Type </span>{
                case "shell":<span class="cov0" title="0"></span>
                case "exec":<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0">
                        continue</span>
                }

                <span class="cov0" title="0">if err := func() error </span><span class="cov0" title="0">{
                        success := false
                        defer func() </span><span class="cov0" title="0">{
                                if err := channel.CloseWrite(); err != nil </span><span class="cov0" title="0">{
                                        log.Warningf("%s: failed to close session: %s", connection, err)
                                }</span>

                                <span class="cov0" title="0">exitStatus := struct{ Status uint32 }{}
                                if !success </span><span class="cov0" title="0">{
                                        exitStatus.Status = 1
                                }</span>
                                <span class="cov0" title="0">if _, err := channel.SendRequest("exit-status", false, ssh.Marshal(exitStatus)); err != nil </span><span class="cov0" title="0">{
                                        log.Warningf("%s: failed to send exit-status for session: %s", connection, err)
                                }</span>

                                <span class="cov0" title="0">if err := channel.Close(); err != nil </span><span class="cov0" title="0">{
                                        log.Warningf("%s: failed to close session: %s", connection, err)
                                }</span>
                        }()

                        // decode command
                        <span class="cov0" title="0">var command string
                        if request.Type == "exec" </span><span class="cov0" title="0">{
                                var execute struct{ Command string }
                                if err := ssh.Unmarshal(request.Payload, &amp;execute); err != nil </span><span class="cov0" title="0">{
                                        log.Errorf("%s: failed to unmarshal request payload: %s: %v", connection, err, request.Payload)
                                        return err
                                }</span>
                                <span class="cov0" title="0">command = execute.Command</span>
                        }

                        // do actual work here
                        <span class="cov0" title="0">if err := runService(command, connection, channel); err != nil </span><span class="cov0" title="0">{
                                log.Errorf("%s: command %s failed: %s", connection, command, err)
                                if _, err2 := fmt.Fprintf(channel.Stderr(), "ERROR: %s\r\n", err); err2 != nil </span><span class="cov0" title="0">{
                                        log.Errorf("%s: failed to write to stdout: %s", connection, err2)
                                }</span>
                                <span class="cov0" title="0">return err</span>
                        }

                        <span class="cov0" title="0">success = true
                        return nil</span>
                }(); err != nil <span class="cov0" title="0">{
                        break</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package gateway

import (
        "io"
        "sync"

        "golang.org/x/crypto/ssh"
)

// a tunnel within a ssh connection
type tunnel struct {
        connection  *connection
        channel     ssh.Channel
        channelType string
        extraData   []byte
        done        chan struct{}
        closeOnce   sync.Once
        metadata    map[string]interface{}
}

func newTunnel(connection *connection, channel ssh.Channel, channelType string, extraData []byte, metadata map[string]interface{}) *tunnel <span class="cov0" title="0">{
        log.Infof("%s: new tunnel: type = %s, metadata = %v", connection, channelType, metadata)
        self := &amp;tunnel{
                connection:  connection,
                channel:     channel,
                channelType: channelType,
                extraData:   extraData,
                done:        make(chan struct{}),
                metadata:    metadata,
        }
        connection.addTunnel(self)
        return self
}</span>

// close the tunnel
func (self *tunnel) close() <span class="cov0" title="0">{
        self.closeOnce.Do(func() </span><span class="cov0" title="0">{
                close(self.done)
        }</span>)
}

func (self *tunnel) handleRequests(requests &lt;-chan *ssh.Request) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                self.connection.deleteTunnel(self)
                if err := self.channel.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Warningf("%s: failed to close tunnel: %s", self.connection, err)
                }</span>
                <span class="cov0" title="0">log.Infof("%s: tunnel closed: type = %s, metadata = %v", self.connection, self.channelType, self.metadata)</span>
        }()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-self.done:<span class="cov0" title="0">
                        return</span>
                case request, ok := &lt;-requests:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        // log.Debugf("%s: request received: type = %s, want_reply = %v, payload = %d", self.connection, request.Type, request.WantReply, len(request.Payload))
                        // reply to client
                        <span class="cov0" title="0">if request.WantReply </span><span class="cov0" title="0">{
                                if err := request.Reply(false, nil); err != nil </span><span class="cov0" title="0">{
                                        log.Errorf("%s: failed to reply to request: %s", self.connection, err)
                                        return
                                }</span>
                        }
                }
        }
}

func (self *tunnel) handleTunnel(otherTunnel *tunnel) <span class="cov0" title="0">{
        defer otherTunnel.close()
        defer self.close()

        done1 := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                defer close(done1)
                _, _ = io.Copy(self.channel, otherTunnel.channel)
        }</span>()

        <span class="cov0" title="0">done2 := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                defer close(done2)
                _, _ = io.Copy(otherTunnel.channel, self.channel)
        }</span>()

        // wait until one of them is done
        <span class="cov0" title="0">select </span>{
        case &lt;-done1:<span class="cov0" title="0"></span>
        case &lt;-done2:<span class="cov0" title="0"></span>
        }
}

type tunnelStatus struct {
        Type     string                 `json:"type,omitempty"`
        Metadata map[string]interface{} `json:"metadata,omitempty"`
}

func (self *tunnel) gatherStatus() *tunnelStatus <span class="cov0" title="0">{
        return &amp;tunnelStatus{
                Type:     self.channelType,
                Metadata: self.metadata,
        }
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package gateway

import (
        "encoding/csv"
        "errors"
        "net"
        "strings"
        "sync/atomic"
        "time"

        "golang.org/x/crypto/ssh"
)

var (
        ErrInvalidForwardRequest = errors.New("gatewaysshd: invalid forward request")
        ErrInvalidTunnelData     = errors.New("gatewaysshd: invalid tunnel data")
)

type forwardRequest struct {
        Host string
        Port uint32
}

func unmarshalForwardRequest(payload []byte) (*forwardRequest, error) <span class="cov0" title="0">{
        request := &amp;forwardRequest{}

        if err := ssh.Unmarshal(payload, request); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // TODO: check host
        <span class="cov0" title="0">if request.Port &gt; 65535 </span><span class="cov0" title="0">{
                return nil, ErrInvalidForwardRequest
        }</span>

        <span class="cov0" title="0">return request, nil</span>
}

// type forwardReply struct {
//         Port uint32
// }

// func marshalForwardReply(reply *forwardReply) []byte {
//         return ssh.Marshal(reply)
// }

type tunnelData struct {
        Host          string
        Port          uint32
        OriginAddress string
        OriginPort    uint32
}

func unmarshalTunnelData(payload []byte) (*tunnelData, error) <span class="cov0" title="0">{
        data := &amp;tunnelData{}

        if err := ssh.Unmarshal(payload, data); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // TODO: check host
        <span class="cov0" title="0">if data.Port &gt; 65535 </span><span class="cov0" title="0">{
                return nil, ErrInvalidTunnelData
        }</span>

        <span class="cov0" title="0">if data.OriginPort &gt; 65535 </span><span class="cov0" title="0">{
                return nil, ErrInvalidTunnelData
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}

func marshalTunnelData(data *tunnelData) []byte <span class="cov0" title="0">{
        return ssh.Marshal(data)
}</span>

// type executeRequest struct {
//         Command string
// }

// func unmarshalExecuteRequest(payload []byte) (*executeRequest, error) {
//         request := &amp;executeRequest{}

//         if err := ssh.Unmarshal(payload, request); err != nil {
//                 return nil, err
//         }

//         return request, nil
// }

type usageStats struct {
        bytesRead    uint64
        bytesWritten uint64
        createdAt    time.Time
        usedAt       time.Time
}

func newUsage() *usageStats <span class="cov0" title="0">{
        return &amp;usageStats{
                createdAt: time.Now(),
                usedAt:    time.Now(),
        }
}</span>

func (u *usageStats) read(bytesRead uint64) <span class="cov0" title="0">{
        u.update(bytesRead, 0)
}</span>

func (u *usageStats) write(bytesWritten uint64) <span class="cov0" title="0">{
        u.update(0, bytesWritten)
}</span>

// func (u *usageStats) use() {
//         u.update(0, 0)
// }

func (u *usageStats) update(bytesRead, bytesWritten uint64) <span class="cov0" title="0">{
        if bytesRead &gt; 0 </span><span class="cov0" title="0">{
                atomic.AddUint64(&amp;u.bytesRead, bytesRead)
        }</span>
        <span class="cov0" title="0">if bytesWritten &gt; 0 </span><span class="cov0" title="0">{
                atomic.AddUint64(&amp;u.bytesWritten, bytesWritten)
        }</span>
        <span class="cov0" title="0">u.usedAt = time.Now()</span>
}

type wrappedConn struct {
        conn  net.Conn
        usage *usageStats
}

func wrapConn(conn net.Conn, usage *usageStats) *wrappedConn <span class="cov0" title="0">{
        return &amp;wrappedConn{
                conn:  conn,
                usage: usage,
        }
}</span>

// override read to keep track of data usage
func (self *wrappedConn) Read(data []byte) (int, error) <span class="cov0" title="0">{
        size, err := self.conn.Read(data)
        if err == nil &amp;&amp; size &gt;= 0 </span><span class="cov0" title="0">{
                self.usage.read(uint64(size)) // safe: size from Read is always non-negative
        }</span>
        <span class="cov0" title="0">return size, err</span>
}

// override write to keep track of data usage
func (self *wrappedConn) Write(data []byte) (int, error) <span class="cov0" title="0">{
        size, err := self.conn.Write(data)
        if err == nil &amp;&amp; size &gt;= 0 </span><span class="cov0" title="0">{
                self.usage.write(uint64(size)) // safe: size from Write is always non-negative
        }</span>
        <span class="cov0" title="0">return size, err</span>
}

func (self *wrappedConn) Close() error <span class="cov0" title="0">{
        return self.conn.Close()
}</span>

func (self *wrappedConn) LocalAddr() net.Addr <span class="cov0" title="0">{
        return self.conn.LocalAddr()
}</span>

func (self *wrappedConn) RemoteAddr() net.Addr <span class="cov0" title="0">{
        return self.conn.RemoteAddr()
}</span>

func (self *wrappedConn) SetDeadline(t time.Time) error <span class="cov0" title="0">{
        return self.conn.SetDeadline(t)
}</span>

func (self *wrappedConn) SetReadDeadline(t time.Time) error <span class="cov0" title="0">{
        return self.conn.SetReadDeadline(t)
}</span>

func (self *wrappedConn) SetWriteDeadline(t time.Time) error <span class="cov0" title="0">{
        return self.conn.SetWriteDeadline(t)
}</span>

func splitCommand(command string) []string <span class="cov0" title="0">{
        reader := csv.NewReader(strings.NewReader(command))
        reader.Comma = ' '
        fields, err := reader.Read()
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return fields</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package main

import (
        "os"

        "github.com/ziyan/gatewaysshd/cli"
)

func main() <span class="cov0" title="0">{
        cli.Run(Version, Commit, os.Args)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package debugutil

import (
        "context"
        "net"
        "net/http"
        "net/http/pprof"
        "time"
)

func RunDebugServer(endpoint string) (func(), error) <span class="cov0" title="0">{
        log.Debugf("listening on debug endpoint: %s", endpoint)
        debugListener, err := net.Listen("tcp", endpoint)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to listen on %q: %s", endpoint, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">debugHandler := http.NewServeMux()
        debugHandler.HandleFunc("/debug/pprof/", pprof.Index)
        debugHandler.HandleFunc("/debug/pprof/cmdline", pprof.Cmdline)
        debugHandler.HandleFunc("/debug/pprof/profile", pprof.Profile)
        debugHandler.HandleFunc("/debug/pprof/symbol", pprof.Symbol)
        debugHandler.HandleFunc("/debug/pprof/trace", pprof.Trace)
        debugServer := &amp;http.Server{
                Handler:           debugHandler,
                ReadHeaderTimeout: 30 * time.Second,
        }
        go func() </span><span class="cov0" title="0">{
                log.Debugf("running and serving debug endpoint")
                if err := debugServer.Serve(debugListener); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Errorf("debug server exited with error: %s", err)
                }</span>
                <span class="cov0" title="0">log.Debugf("stop serving debug endpoint")</span>
        }()
        <span class="cov0" title="0">return func() </span><span class="cov0" title="0">{
                if err := debugServer.Shutdown(context.Background()); err != nil </span><span class="cov0" title="0">{
                        log.Errorf("failed to shutdown debug server: %s", err)
                }</span>
        }, nil
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package debugutil

import (
        "bytes"
        "runtime/pprof"

        "github.com/op/go-logging"
)

var log = logging.MustGetLogger("debugutil")

func GetAllStacks() string <span class="cov0" title="0">{
        var buffer bytes.Buffer
        if err := pprof.Lookup("goroutine").WriteTo(&amp;buffer, 1); err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get all stacks: %s", err)
        }</span>
        <span class="cov0" title="0">return buffer.String()</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
